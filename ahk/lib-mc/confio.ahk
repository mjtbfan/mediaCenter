#Include string.ahk
#Include std.ahk

; class containing configuration data from a file
;  subConfig - map of configs based on groupings from config file
;  items - map of individual settings from config file (left of deliminator = key | right = value)
class Config {
	subConfigs := Map()
	items := Map()

	cleanItems() {
		for key, value in this.items {
			try {
				this.items[key] := Float(value)
			}
			catch {
				if (StrLower(value) = "true") {
					this.items[key] := true
				}
				else if (StrLower(value) = "false") {
					this.items[key] := false
				}
				else if (InStr(value, ",")) {
					this.items[key] := StrSplit(value, ",")
				}
			}
		}
	}

	cleanAllItems() {
		this.cleanItems()

		for key, value in this.subConfigs {
			value.cleanitems()
		}
	}
}

; reads from a file/string and generates a Config object
;  toRead - string/file to read
;  deliminator - string containing separator between a setting's key and value
;  subConfigType - how config file is formatted with its categories of configs
;                - brackets -> standard config file using bracketed category names 
;                - [TODO] xml -> formatted like an xml document with <x>...</x>
;                - [TODO] indents_x_y -> using indentation (x = number of indents per level | y = type (spaces/tabs))
;                - none -> config file contains no categories
;  subConfig - list of categories to find, empty = all categories
;
; returns Config object
readConfig(toRead, deliminator := "=", subConfigType := "none", subConfig := "") {
	retConfig := Config.New()
	configString := fileOrString(toRead)
	
	; helper
	readConfigLoop(confName := "") {
		tempConfig := Config.New()

		currentConf := ""
		currentItem := []

		leftItem := ""
		rightItem := ""

		loop parse configString, "`n", "`r" {
			cleanLine := Trim(A_LoopField, " `t`r`n")
			subConfigLine := false
			
			if (cleanLine = "" || RegExMatch(cleanLine, "U)^;")) {
				continue
			}

			; subConfigType
			switch subConfigType {
				case "brackets":
					; find a group 
					if ((confName = "" && RegExMatch(cleanLine, "U)^\[.*\]$"))
					|| (confName != "" && RegExMatch(cleanLine, "U)^\[ *" . regexClean(confName) . " *\]$"))) {
						
						; replace 
						currentConf := RegExReplace(cleanLine, "U)^\[|\]$", "")
						currentConf := RegExReplace(currentConf, "U)\] *\[", "-")

						tempConfig.subConfigs[currentConf] := Config.New()

						subConfigLine := true
					}
			}
			
			if (!subConfigLine) {
				; create redundent map if no denominator
				if (deliminator != "") {
					currentItem := StrSplit(cleanLine, deliminator,, 2)

					leftItem := Trim(currentItem[1], " `t`r`n")
					rightItem := Trim(currentItem[2], " `t`r`n")
				}
				else {
					leftItem := cleanLine
					rightItem := ""
				}
				
				; add to generic items if no current subConfig
				if (currentConf != "") {
					tempConfig.subConfigs[currentConf].items[leftItem] := rightItem
				}
				else {
					tempConfig.items[leftItem] := rightItem
				}
			}
			
		}

		return tempConfig
	}

	if (IsObject(subConfig) && subConfig.Length > 1) {
		for confIndex, confName in subConfig {
			retConfig.subConfigs[confName] := readConfigLoop(confName)
		}
	}
	else {
		retConfig := readConfigLoop()
	}

	return retConfig
}

; reads custom formatted multicfg files with readConfig() on each requested one
;  fileName - multicfg file to read
;  configList - list of configs to find in multicfg
;  configListType - how to handle multiple values in configList (either "and" or "or")
;  checkDefault - check if multicfg contains default values to be overwritten
;  deliminator / subConfigType / subConfig - see readConfig()
; 
; returns Config object generated by readConfig()
findMultiCfg(fileName, configList := "", configListType := "or", checkDefault := true
	, deliminator := "=", subConfigType := "none", subConfig := "") {

}

; creates the config\global.txt if it doesn't exist (copying global.default.txt), and tells the user to
; fill out the config file. Otherwise returns the cleaned config object
;
; returns an error message or the cleaned config object from global.txt
readGlobalConfig() {
	; first check if global.txt exists
	if (FileExist("config\global.txt")) {
		gConfig := readConfig("config\global.txt", , "brackets")

		; check the required settings from the config file (you bet they're hardcoded)
		if (!gConfig.subConfigs.Has("General") || !gConfig.subConfigs.Has("Display")
		|| !gConfig.subConfigs.Has("LoadScreen") || !gConfig.subConfigs.Has("Pause")
		|| !gConfig.subConfigs.Has("Boot") || !gConfig.subConfigs.Has("Executables")) {
			MsgBox("
				(
					ERROR
					Config global.txt is missing required setting categories
					Please check that all of the required settings exist
				)"
			)

			WinWaitClose()

			ExitApp()
		}
		else if ((!gConfig.subConfigs["Executables"].items.Has("Home")
		|| !gConfig.subConfigs["Executables"].items.Has("HomeDir"))
		|| (gConfig.subConfigs["Executables"].items["Home"] = "" 
		|| gConfig.subConfigs["Executables"].items["HomeDir"] = "")) {
			MsgBox("
				(
					ERROR
					No Home/HomeDir Executables in config\global.txt
					These settings are required to have values for the 
					scripts to function.
				)"
			)

			WinWaitClose()

			ExitApp()
		}

		; if global.txt is valid, return the cleaned copy of it
		gConfig.cleanAllItems()
		return gConfig
	}
	else {
		; if there is no global.txt or global.default.txt, you have to find them
		if (!FileExist("config\global.default.txt")) {
			MsgBox("
				(
					ERROR
					There are literally no config files in config\
					No global.txt & No global.default.txt
					You really screwed the pooch on this one bud
				)"
			)

			WinWaitClose()

			ExitApp()
		}

		defaultGlobal := FileOpen("config\global.default.txt", "r")
		defaultContents := defaultGlobal.Read()
		defaultGlobal.Close()

		newGlobal := FileOpen("config\global.txt", "w")
		newGlobal.Write(defaultContents)
		newGlobal.Close()
		
		MsgBox("
			(
				Welcome to the Media Center AHK Scripts
				A new config file has been generated at config\global.txt
				based on the default settings. Please review the config file
				before trying to run the program again.
			)"
		)

		WinWaitClose()

		ExitApp()
	}
}