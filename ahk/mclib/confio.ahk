#Include string.ahk

; class containing configuration data from a file
;  subConfig - map of configs based on groupings from config file
;  items - map of individual settings from config file (left of deliminator = key | right = value)
class Config {
	subConfigs := Map()
	items := Map()

	cleanItems() {
		for key, value in this.items {
			try {
				this.items[key] := Float(value)
			}
			catch {
				if (StrLower(value) = "true") {
					this.items[key] := true
				}
				else if (StrLower(value) = "false") {
					this.items[key] := false
				}
			}
		}
	}

	cleanAllItems() {
		this.cleanItems()

		for key, value in this.subConfigs {
			value.cleanitems()
		}
	}
}

; reads from a file/string and generates a Config object
;  toRead - string/file to read
;  deliminator - string containing separator between a setting's key and value
;  subConfigType - how config file is formatted with its categories of configs
;                - brackets -> standard config file using bracketed category names 
;                - [TODO] xml -> formatted like an xml document with <x>...</x>
;                - [TODO] indents_x_y -> using indentation (x = number of indents per level | y = type (spaces/tabs))
;                - none -> config file contains no categories
;  subConfig - list of categories to find, empty = all categories
;
; returns Config object
readConfig(toRead, deliminator := "=", subConfigType := "none", subConfig := "") {
	configString := ""
	
	if (FileExist(toRead)) {
		file := FileOpen(toRead, "r")
		configString := file.Read()
		file.Close()
	}
	else {
		configString := toRead
	}

	retConfig := Config.New()

	readConfigLoop(confName := "") {
		tempConfig := Config.New()

		currentConf := ""
		currentItem := []

		loop parse configString, "`n", "`r" {
			cleanLine := Trim(A_LoopField, " `t`r`n")
			
			if (cleanLine = "" || RegExMatch(cleanLine, "U)^;")) {
				continue
			}

			; subConfigType
			switch subConfigType {
				case "brackets":
					; find a group 
					if ((confName = "" && RegExMatch(cleanLine, "U)^\[.*\]$"))
					|| (confName != "" && RegExMatch(cleanLine, "U)^\[ *" . regexClean(confName) . " *\]$"))) {
						
						; replace 
						currentConf := RegExReplace(cleanLine, "U)^\[|\]$", "")
						currentConf := RegExReplace(currentConf, "U)\] *\[", "-")

						tempConfig.subConfigs[currentConf] := Config.New()
					}
			}
			
			currentItem := StrSplit(cleanLine, deliminator,, 2)

			if (currentItem.Length = 2) {
				left := Trim(currentItem[1], " `t`r`n")
				right := Trim(currentItem[2], " `t`r`n")
				
				if (currentConf != "") {
					tempConfig.subConfigs[currentConf].items[left] := right
				}
				else {
					tempConfig.items[left] := right
				}
			}
			
		}

		return tempConfig
	}

	if (IsObject(subConfig) && subConfig.Length > 1) {
		for confIndex, confName in subConfig {
			retConfig.subConfigs[confName] := readConfigLoop(confName)
		}
	}
	else {
		retConfig := readConfigLoop()
	}

	return retConfig
}

; reads custom formatted multicfg files with readConfig() on each requested one
;  fileName - multicfg file to read
;  configList - list of configs to find in multicfg
;  configListType - how to handle multiple values in configList (either "and" or "or")
;  checkDefault - check if multicfg contains default values to be overwritten
;  deliminator / subConfigType / subConfig - see readConfig()
; 
; returns Config object generated by readConfig()
findMultiCfg(fileName, configList := "", configListType := "or", checkDefault := true
	, deliminator := "=", subConfigType := "none", subConfig := "") {

}